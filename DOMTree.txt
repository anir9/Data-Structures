# DOMTree
I created the DOMTree project using the Eclipse IDE for my Data Structures(112) class. Its purpose is to create a Document Object Model (DOMTree) in Java, given data from an HTML file. The professor created a custom structure called a TagNode that we were told to use for this project. The program should be able to print the tree without any "<", ">", or "/" characters, print the HTML file, delete all instances of a specified tag, replace all instances of a specified tag with a new tag, add a tag to the tree, and boldface an entire row in a table. A TagNode works similarly to a linked list node structure. The TagNode class allows TagNodes to contain a String or a "tag". It also allows for two types of links, one for the firstChild of the node and one for the siblings. The firstChild of a TagNode is the TagNode that has a direct branch to a higher TagNode, and visually "sits" vertically under it in the DOMTree. This is commonly seen whenever a tag (i.e. html, body) occurs in the html file, when a new paragraph is made(p), a table column or row is made (td, tr), or when text is boldfaced(b) and/or italicized(em). Siblings of a TagNode are linked "horizontally" to the node in question, and usually found in tables or in tags consisting of text phrases of two or more words. 
# build()
    In the file Tree.java you can see my code. In the build() method which builds the DOMTree from the input HTML file using the scanner class, I take each line from the HTML file, create it as a new TagNode called "root", and push each root onto a Stack. As the scanner parses through each line of the file, the text in that line is saved as a String "x". I use the .contains() method to check whether or not the String contains a normal HTML tag or basic text. The build() method skips markers that indicate the end of a textural structure (i.e. "/p") by popping them from the stack. 
    If the String is a tag, (contains a "<"), then .substring() removes the "<>" from the String and saves the tag as a new TagNode "n". Then I link the new TagNode to its proper parent and siblings. If the parent TagNode does not have a firstChild, it saves TagNode n as the new firstChild. If the parent TagNode already has a firstChild, the program saves the firstChild as the TagNode maybe. Then the while loop iterates through maybe's siblings until it reaches the last one (the sibling farthest to the right of the tree). It links "n" to be the new last sibling. The TagNode n is then pushed onto the stack. 
    If the String is plain text, the String is saved as a new TagNode "n". The method repeats the same process for if the String is a tag, except the TagNode is not pushed onto the stack in the end. 
# replaceTraverse()
    For the private method replaceTraverse, I use a for loop to traverse the tree, calling the current TagNode "ptr" or pointer. I use  .equals() to find the nodes with the to-be-replaced String "oldTag" and then overwrite the node's tag with the replacement String "newTag". The method is called recursively until all tags are replaces and each ptr is pushed onto the stack. 
# boldTraverse()
    For the private method boldTraverse, I use the same traversal method as I do in replaceTraverse(). The method counts the number of rows in a table, and then boldfaces (adds a "b" tag) to each element in the specified row number. The method is called recursively until all appropriate tags are boldfaced. 
# removeTraverse()
    For the private method removeTraverse, I use the same traversal method as I do in replaceTraverse(). I use .equals() to find the nodes with the to-be-deleted "tag". I use .peek() to find the node which was added to the stack before ptr. If the node is an HTML tag, the last added node to the stack is saved as a new TagNode prev. 
    If prev is ptr's sibling, a for loop traverses the siblings of ptr.firstChild until it reaches the last one. The last sibling of ptr.firstChild is saved as a new TagNode temp. If ptr.firstChild has any siblings, the last sibling becomes temp's sibling, and ptr.firstChild becomes prev's sibling. If there are no siblings of ptr.firstChild, ptr.sibling becomes the firstChild's sibling, and prev's sibling is ptr.firstChild. If prev is the parent node, a similar process is repeated. 
    If the tag to be removed is a list (HTML tags "ol" or "ul"), we temporarily save ptr to a new TagNode "current". Then ptr = ptr.firstChild and the while loops changes all the list tags to "p" tags. And we restore ptr to its original node before the while loop. The same deletion process is repeated once again, with the method called recursively so that each tag is deleted and the new order is pushed onto the stack. 
# addTraverse()
     For the private method addTraverse, I use the same traversal method as I do in replaceTraverse(). This method adds tags around all occurrences of a word in a DOM Tree. Here, I use StringTokenizer to split each line of the HTML text into its separate words and save them onto a Stack called "main". The current word we are looking at is popped out of the stack and saved as the String "now". Then, .matches() is used to compare the current token with the word that needs to be added "tag". The method saves any characters before "tag" as the String beforeSub. When the target word is found, the integer endOfLast saves index of the character immediately after the word, ommitting punctuation. The TagNode newWord saves the word without punctuation. The code searches for every instance of the inputted "tag" using recursion and repeats the same process. Once a text is fully scanned, a TagNode is created for both the new "tag" (TagNode emphasis) and for any text after the last instance of the word (afterWord). A series of if and else statements put "emphasis" in its proper places in the tree. All TagNode ptr is pushed onto the stack.
# Comments
    I recognize that my code is not as clean as it could be and there are a few bugs that need to be addressed. I also realize that this may not be the most efficient method to accomplish this task. However, I am still willing to make improvements and additions to my coding skills. 
